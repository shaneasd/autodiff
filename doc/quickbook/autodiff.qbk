[/          Copyright Matthew Pulver 2018 - 2019.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)]

[section:autodiff Automatic Differentiation]
[template autodiff_equation[name]  '''<inlinemediaobject><imageobject><imagedata fileref="../equations/autodiff/'''[name]'''"></imagedata></imageobject></inlinemediaobject>''']

[h1:synopsis Synopsis]

    #include <boost/math/differentiation/autodiff.hpp>
    
    namespace boost { namespace math { namespace differentiation {
    
    // Type of combined autodiff types.
    template<typename RealType, typename... RealTypes>
    using promote = typename detail::promote_args_n<RealType,RealTypes...>::type;
    
    // Type for variables and constants. 
    template<typename RealType, size_t Order, size_t... Orders>
    using autodiff_fvar = typename detail::nest_fvar<RealType,Order,Orders...>::type;
    
    // Function returning a variable of differentiation.
    template<typename RealType, size_t Order, size_t... Orders>
    autodiff_fvar<RealType,Order,Orders...> make_fvar(const RealType& ca);
    
    namespace detail {
    
    // Single autodiff variable. Independent variables are created by nesting.
    template<typename RealType, size_t Order>
    class fvar
    {
      public:
    
        // Query return value of function to get the derivatives.
        template<typename... Orders>
        get_type_at<RealType, sizeof...(Orders)-1> derivative(Orders... orders) const;
    
        // All of the arithmetic and comparison operators are overloaded.
        template<typename RealType2, size_t Order2>
        fvar& operator+=(const fvar<RealType2,Order2>&);
    
        fvar& operator+=(const root_type&);
    
        // ...
    };
    
    // Standard math functions are overloaded and called via argument-dependent lookup (ADL).
    template<typename RealType, size_t Order>
    fvar<RealType,Order> floor(const fvar<RealType,Order>&);
    
    template<typename RealType, size_t Order>
    fvar<RealType,Order> exp(const fvar<RealType,Order>&);
    
    // ...
    
    } // namespace detail
    
    } } } // namespace boost::math::differentiation


[h1:description Description]

Autodiff is a header-only C++ library that facilitates the [@https://en.wikipedia.org/wiki/Automatic_differentiation
automatic differentiation] (forward mode) of mathematical functions of single and multiple variables.

This implementation is based upon the [@https://en.wikipedia.org/wiki/Taylor_series Taylor series] expansion of
an analytic function /f/ at the point ['x[sub 0]]:

[/ \Large\begin{align*}
f(x_0+\varepsilon) &= f(x_0) + f'(x_0)\varepsilon + \frac{f''(x_0)}{2!}\varepsilon^2 + \frac{f'''(x_0)}{3!}\varepsilon^3 + \cdots \\
  &= \sum_{n=0}^N\frac{f^{(n)}(x_0)}{n!}\varepsilon^n + O\left(\varepsilon^{N+1}\right).
\end{align*} ]
[:[:[autodiff_equation taylor_series.svg]]]

The essential idea of autodiff is the replacement of numbers with polynomials in the evaluation of /f/. By inputting
the first-order polynomial ['x[sub 0]+\u03b5], the resulting polynomial in ['\u03b5] contains the function's
derivatives within the coefficients. One then multiplies by a factorial term to obtain the desired derivative of
any order.

Assume one is interested in the first /N/ derivatives of /f/ at ['x[sub 0]]. Then without any loss of precision
to the calculation of the derivatives, all terms ['O(\u03b5[super N+1])] that include powers of ['\u03b5] greater
than /N/ can be discarded, and under these truncation rules, /f/ provides a polynomial-to-polynomial transformation:

[/ \Large$$f\quad:\quad x_0+\varepsilon\quad\mapsto\quad\sum_{n=0}^N\frac{f^{(n)}(x_0)}{n!}\varepsilon^n.$$ ]
[:[:[autodiff_equation polynomial_transform.svg]]]

C++'s ability to overload operators and functions allows for the creation of a class `fvar` that represents
polynomials in ['\u03b5]. Thus the same logic that calculates the numeric value of ['f(x[sub 0])] also calculates
the polynomial ['f(x[sub 0]+\u03b5)]. The derivatives are then found in the coefficients of the return value.


[h1:examples Examples]

[h2:example-single-variable Example 1: Single-variable derivatives]

[h3 Calculate derivatives of ['f(x)=x[super 4]] at /x/=2.]

In this example, `autodiff_fvar<double,5>` is a data type that can hold a polynomial of up to degree 5,
and `make_fvar<double,5>(2.0)` represents the polynomial 2+['\u03b5]. Internally, this is modeled by a
`std::array<double,6>` whose elements correspond to the 6 coefficients of the polynomial: `{2, 1, 0, 0, 0, 0}`
upon initialization.

    #include <boost/math/differentiation/autodiff.hpp>
    #include <iostream>
    
    template<typename T>
    T fourth_power(T x)
    {
        x *= x;
        return x *= x;
    }
    
    int main()
    {
        using namespace boost::math::differentiation;
    
        constexpr int Order=5; // The highest order derivative to be calculated.
        const autodiff_fvar<double,Order> x = make_fvar<double,Order>(2.0); // Find derivatives at x=2.
        const autodiff_fvar<double,Order> y = fourth_power(x);
        for (int i=0 ; i<=Order ; ++i)
            std::cout << "y.derivative("<<i<<") = " << y.derivative(i) << std::endl;
        return 0;
    }

The above calculates 

[/ \Large\begin{alignat*}{3}
{\tt y.derivative(0)} &=& f(2) =&& \left.x^4\right|_{x=2} &= 16\\
{\tt y.derivative(1)} &=& f'(2) =&& \left.4\cdot x^3\right|_{x=2} &= 32\\
{\tt y.derivative(2)} &=& f''(2) =&& \left.4\cdot 3\cdot x^2\right|_{x=2} &= 48\\
{\tt y.derivative(3)} &=& f'''(2) =&& \left.4\cdot 3\cdot2\cdot x\right|_{x=2} &= 48\\
{\tt y.derivative(4)} &=& f^{(4)}(2) =&& 4\cdot 3\cdot2\cdot1 &= 24\\
{\tt y.derivative(5)} &=& f^{(5)}(2) =&& 0 &
\end{alignat*} ]
[:[:[autodiff_equation example1.svg]]]

[h2:example-multiprecision 
Example 2: Multi-variable mixed partial derivatives with multi-precision data type]

[/ \Large$\frac{\partial^{12}f}{\partial w^{3}\partial x^{2}\partial y^{4}\partial z^{3}}(11,12,13,14)$]
[/ \Large$f(w,x,y,z)=\exp\left(w\sin\left(\frac{x\log(y)}{z}\right)+\sqrt{\frac{wz}{xy}}\right)+\frac{w^2}{\tan(z)}$]
[h3 Calculate [autodiff_equation mixed12.svg] with a precision of about 100 decimal digits,
where [autodiff_equation example2f.svg].]

In this example, the data type `autodiff_fvar<cpp_dec_float_100,Nw,Nx,Ny,Nz>` represents a polynomial in 4
independent variables, where the highest powers of each are `Nw`, `Nx`, `Ny` and `Nz`. The underlying arithmetic
data type, aliased as `root_type`, is `boost::multiprecision::cpp_dec_float_100`. The internal data type is
`std::array<std::array<std::array<std::array<cpp_dec_float_100,Nz+1>,Ny+1>,Nx+1>,Nw+1>`.  The `root_type` is
always the first template parameter to `autodiff_fvar<...>` followed by the maximum derivative orders that are to
be calculated for each independent variable.

When variables are initialized by `make_fvar<...>()`, the position of the last derivative order given in the
parameter pack determines which variable is taken to be independent. In other words, it determines which of the 4
different polynomial variables ['\u03b5[sub w]], ['\u03b5[sub x]], ['\u03b5[sub y]], or ['\u03b5[sub z]]  are to
be added to the input value:

[/ \Large\begin{align*}
\texttt{make\_fvar<cpp\_dec\_float\_100,Nw>(11)} &= 11+\varepsilon_w \\
\texttt{make\_fvar<cpp\_dec\_float\_100,0,Nx>(12)} &= 12+\varepsilon_x \\
\texttt{make\_fvar<cpp\_dec\_float\_100,0,0,Ny>(13)} &= 13+\varepsilon_y \\
\texttt{make\_fvar<cpp\_dec\_float\_100,0,0,0,Nz>(14)} &= 14+\varepsilon_z
\end{align*}\]
[:[:[autodiff_equation example2make_fvar.svg]]]

Instances of different types are automatically promoted to the smallest multi-variable type that accommodates both
when they are combined (added, subtracted, multiplied, divided.)

    #include <boost/math/differentiation/autodiff.hpp>
    #include <boost/multiprecision/cpp_dec_float.hpp>
    #include <iostream>
    
    template<typename T>
    T f(const T& w, const T& x, const T& y, const T& z)
    {
      using namespace std;
      return exp(w*sin(x*log(y)/z) + sqrt(w*z/(x*y))) + w*w/tan(z);
    }
    
    int main()
    {
      using cpp_dec_float_100 = boost::multiprecision::cpp_dec_float_100;
      using namespace boost::math::differentiation;
    
      constexpr int Nw=3; // Max order of derivative to calculate for w
      constexpr int Nx=2; // Max order of derivative to calculate for x
      constexpr int Ny=4; // Max order of derivative to calculate for y
      constexpr int Nz=3; // Max order of derivative to calculate for z
      using var = autodiff_fvar<cpp_dec_float_100,Nw,Nx,Ny,Nz>;
      const var w = make_fvar<cpp_dec_float_100,Nw>(11);
      const var x = make_fvar<cpp_dec_float_100,0,Nx>(12);
      const var y = make_fvar<cpp_dec_float_100,0,0,Ny>(13);
      const var z = make_fvar<cpp_dec_float_100,0,0,0,Nz>(14);
      const var v = f(w,x,y,z);
      // Calculated from Mathematica symbolic differentiation. See multiprecision.nb for script.
      const cpp_dec_float_100 answer("1976.31960074779771777988187529041872090812118921875499076582535951111845769110560421820940516423255314");
      std::cout << std::setprecision(std::numeric_limits<cpp_dec_float_100>::digits10)
        << "mathematica   : " << answer << '\n'
        << "autodiff      : " << v.derivative(Nw,Nx,Ny,Nz) << '\n'
        << "relative error: " << std::setprecision(3) << (v.derivative(Nw,Nx,Ny,Nz)/answer-1) << std::endl;
      return 0;
    }
    /*
    Output:
    mathematica   : 1976.319600747797717779881875290418720908121189218754990765825359511118457691105604218209405164232553
    autodiff      : 1976.319600747797717779881875290418720908121189218754990765825359511118457691105604218209405164232566
    relative error: 6.47e-99
    */


[h2:example-black-scholes 
Example 3: Black-Scholes option pricing]

[h3 Using the standard Black-Scholes model for pricing European options, calculate call/put prices and greeks.]

[@https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks]

One of the primary benefits of using automatic differentiation is the elimination of additional functions to calculate derivatives, which is a form of code redundancy.  

    #include <boost/math/differentiation/autodiff.hpp>
    #include <iostream>
    
    using namespace boost::math::differentiation;
    
    // Equations and function/variable names are from
    // https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks
    
    // Standard normal probability density function
    template<typename X>
    X phi(const X& x)
    {
      return boost::math::constants::one_div_root_two_pi<double>()*exp(-0.5*x*x);
    }
    
    // Standard normal cumulative distribution function
    template<typename X>
    X Phi(const X& x)
    {
      return 0.5*erfc(-boost::math::constants::one_div_root_two<double>()*x);
    }
    
    enum CP { call, put };
    
    // Assume zero annual dividend yield (q=0).
    template<typename Price,typename Sigma,typename Tau,typename Rate>
    autodiff::promote<Price,Sigma,Tau,Rate>
        black_scholes_option_price(CP cp, double K, const Price& S, const Sigma& sigma, const Tau& tau, const Rate& r)
    {
      using namespace std;
      const auto d1 = (log(S/K) + (r+sigma*sigma/2)*tau) / (sigma*sqrt(tau));
      const auto d2 = (log(S/K) + (r-sigma*sigma/2)*tau) / (sigma*sqrt(tau));
      if (cp == call)
        return S*Phi(d1) - exp(-r*tau)*K*Phi(d2);
      else
        return exp(-r*tau)*K*Phi(-d2) - S*Phi(-d1);
    }
    
    int main()
    {
      const double K = 100.0; // Strike price.
      const autodiff::variable<double,3> S(105); // Stock price.
      const autodiff::variable<double,0,3> sigma(5); // Volatility.
      const autodiff::variable<double,0,0,1> tau(30.0/365); // Time to expiration in years. (30 days).
      const autodiff::variable<double,0,0,0,1> r(1.25/100); // Interest rate.
      const auto call_price = black_scholes_option_price(call, K, S, sigma, tau, r);
      const auto put_price  = black_scholes_option_price(put,  K, S, sigma, tau, r);
    
      // Compare automatically calculated greeks by autodiff with formulas for greeks.
      // https://en.wikipedia.org/wiki/Greeks_(finance)#Formulas_for_European_option_Greeks
      const double d1 = static_cast<double>((log(S/K) + (r+sigma*sigma/2)*tau) / (sigma*sqrt(tau)));
      const double d2 = static_cast<double>((log(S/K) + (r-sigma*sigma/2)*tau) / (sigma*sqrt(tau)));
      const double formula_call_delta = +Phi(+d1);
      const double formula_put_delta  = -Phi(-d1);
      const double formula_vega = static_cast<double>(S*phi(d1)*sqrt(tau));
      const double formula_call_theta = static_cast<double>(-S*phi(d1)*sigma/(2*sqrt(tau))-r*K*exp(-r*tau)*Phi(+d2));
      const double formula_put_theta  = static_cast<double>(-S*phi(d1)*sigma/(2*sqrt(tau))+r*K*exp(-r*tau)*Phi(-d2));
      const double formula_call_rho = static_cast<double>(+K*tau*exp(-r*tau)*Phi(+d2));
      const double formula_put_rho  = static_cast<double>(-K*tau*exp(-r*tau)*Phi(-d2));
      const double formula_gamma = static_cast<double>(phi(d1)/(S*sigma*sqrt(tau)));
      const double formula_vanna = static_cast<double>(-phi(d1)*d2/sigma);
      const double formula_charm = static_cast<double>(phi(d1)*(d2*sigma*sqrt(tau)-2*r*tau)/(2*tau*sigma*sqrt(tau)));
      const double formula_vomma = static_cast<double>(S*phi(d1)*sqrt(tau)*d1*d2/sigma);
      const double formula_veta = static_cast<double>(-S*phi(d1)*sqrt(tau)*(r*d1/(sigma*sqrt(tau))-(1+d1*d2)/(2*tau)));
      const double formula_speed = static_cast<double>(-phi(d1)*(d1/(sigma*sqrt(tau))+1)/(S*S*sigma*sqrt(tau)));
      const double formula_zomma = static_cast<double>(phi(d1)*(d1*d2-1)/(S*sigma*sigma*sqrt(tau)));
      const double formula_color =
        static_cast<double>(-phi(d1)/(2*S*tau*sigma*sqrt(tau))*(1+(2*r*tau-d2*sigma*sqrt(tau))*d1/(sigma*sqrt(tau))));
      const double formula_ultima = -formula_vega*static_cast<double>((d1*d2*(1-d1*d2)+d1*d1+d2*d2)/(sigma*sigma));
    
      std::cout << std::setprecision(std::numeric_limits<double>::digits10)
        << "autodiff black-scholes call price = " << call_price.derivative(0,0,0,0) << '\n'
        << "autodiff black-scholes put  price = " << put_price.derivative(0,0,0,0) << '\n'
        << "\n## First-order Greeks\n"
        << "autodiff call delta = " << call_price.derivative(1,0,0,0) << '\n'
        << " formula call delta = " << formula_call_delta << '\n'
        << "autodiff call vega  = " << call_price.derivative(0,1,0,0) << '\n'
        << " formula call vega  = " << formula_vega << '\n'
        << "autodiff call theta = " << -call_price.derivative(0,0,1,0) << '\n' // minus sign due to tau = T-time
        << " formula call theta = " << formula_call_theta << '\n'
        << "autodiff call rho   = " << call_price.derivative(0,0,0,1) << '\n'
        << " formula call rho   = " << formula_call_rho << '\n'
        << '\n'
        << "autodiff put delta = " << put_price.derivative(1,0,0,0) << '\n'
        << " formula put delta = " << formula_put_delta << '\n'
        << "autodiff put vega  = " << put_price.derivative(0,1,0,0) << '\n'
        << " formula put vega  = " << formula_vega << '\n'
        << "autodiff put theta = " << -put_price.derivative(0,0,1,0) << '\n'
        << " formula put theta = " << formula_put_theta << '\n'
        << "autodiff put rho   = " << put_price.derivative(0,0,0,1) << '\n'
        << " formula put rho   = " << formula_put_rho << '\n'
        << "\n## Second-order Greeks\n"
        << "autodiff call gamma = " << call_price.derivative(2,0,0,0) << '\n'
        << "autodiff put  gamma = " << put_price.derivative(2,0,0,0) << '\n'
        << "      formula gamma = " << formula_gamma << '\n'
        << "autodiff call vanna = " << call_price.derivative(1,1,0,0) << '\n'
        << "autodiff put  vanna = " << put_price.derivative(1,1,0,0) << '\n'
        << "      formula vanna = " << formula_vanna << '\n'
        << "autodiff call charm = " << -call_price.derivative(1,0,1,0) << '\n'
        << "autodiff put  charm = " << -put_price.derivative(1,0,1,0) << '\n'
        << "      formula charm = " << formula_charm << '\n'
        << "autodiff call vomma = " << call_price.derivative(0,2,0,0) << '\n'
        << "autodiff put  vomma = " << put_price.derivative(0,2,0,0) << '\n'
        << "      formula vomma = " << formula_vomma << '\n'
        << "autodiff call veta = " << call_price.derivative(0,1,1,0) << '\n'
        << "autodiff put  veta = " << put_price.derivative(0,1,1,0) << '\n'
        << "      formula veta = " << formula_veta << '\n'
        << "\n## Third-order Greeks\n"
        << "autodiff call speed = " << call_price.derivative(3,0,0,0) << '\n'
        << "autodiff put  speed = " << put_price.derivative(3,0,0,0) << '\n'
        << "      formula speed = " << formula_speed << '\n'
        << "autodiff call zomma = " << call_price.derivative(2,1,0,0) << '\n'
        << "autodiff put  zomma = " << put_price.derivative(2,1,0,0) << '\n'
        << "      formula zomma = " << formula_zomma << '\n'
        << "autodiff call color = " << call_price.derivative(2,0,1,0) << '\n'
        << "autodiff put  color = " << put_price.derivative(2,0,1,0) << '\n'
        << "      formula color = " << formula_color << '\n'
        << "autodiff call ultima = " << call_price.derivative(0,3,0,0) << '\n'
        << "autodiff put  ultima = " << put_price.derivative(0,3,0,0) << '\n'
        << "      formula ultima = " << formula_ultima << '\n'
        ;
      return 0;
    }
    /*
    Output:
    autodiff black-scholes call price = 56.5136030677739
    autodiff black-scholes put  price = 51.4109161009333
    
    ## First-order Greeks
    autodiff call delta = 0.773818444921273
     formula call delta = 0.773818444921274
    autodiff call vega  = 9.05493427705736
     formula call vega  = 9.05493427705736
    autodiff call theta = -275.73013426444
     formula call theta = -275.73013426444
    autodiff call rho   = 2.03320550539396
     formula call rho   = 2.03320550539396
    
    autodiff put delta = -0.226181555078726
     formula put delta = -0.226181555078726
    autodiff put vega  = 9.05493427705736
     formula put vega  = 9.05493427705736
    autodiff put theta = -274.481417851526
     formula put theta = -274.481417851526
    autodiff put rho   = -6.17753255212599
     formula put rho   = -6.17753255212599
    
    ## Second-order Greeks
    autodiff call gamma = 0.00199851912993254
    autodiff put  gamma = 0.00199851912993254
          formula gamma = 0.00199851912993254
    autodiff call vanna = 0.0410279463126531
    autodiff put  vanna = 0.0410279463126531
          formula vanna = 0.0410279463126531
    autodiff call charm = -1.2505564233679
    autodiff put  charm = -1.2505564233679
          formula charm = -1.2505564233679
    autodiff call vomma = -0.928114149313108
    autodiff put  vomma = -0.928114149313108
          formula vomma = -0.928114149313107
    autodiff call veta = 26.7947073115641
    autodiff put  veta = 26.7947073115641
          formula veta = 26.7947073115641
    
    ## Third-order Greeks
    autodiff call speed = -2.90117322380992e-05
    autodiff put  speed = -2.90117322380992e-05
          formula speed = -2.90117322380992e-05
    autodiff call zomma = -0.000604548369901419
    autodiff put  zomma = -0.000604548369901419
          formula zomma = -0.000604548369901419
    autodiff call color = -0.0184014426606065
    autodiff put  color = -0.0184014426606065
          formula color = -0.0184014426606065
    autodiff call ultima = -0.0922426864775683
    autodiff put  ultima = -0.0922426864775683
          formula ultima = -0.0922426864775685
    **/



[h2:example-multi-variable 
Example 4: Multi-variable mixed partial derivatives]

[h3 Calculate mixed partial derivatives of [autodiff_equation form_13.png] at [autodiff_equation form_17.png].]

This example calculates 

[:[:[autodiff_equation form_18.png]]]


where [autodiff_equation form_19.png]. For testing purposes, the [autodiff_equation form_20.png]-element `answers[]` array was calculated independently by Mathematica in 2 steps:


# [@https://reference.wolfram.com/language/tutorial/SymbolicComputation.html Symbolic differentiation]
# [@https://reference.wolfram.com/language/tutorial/ArbitraryPrecisionNumbers.html Arbitrary-precision computation] to calculate the answers to 20 decimal places.

Out of the 240 calculated values, the maximum relative error between the values calculated by Mathematica vs. the Boost Autodiff library is found to be about [autodiff_equation form_21.png] using the standard IEEE double precision floating point data type. Since the data type is a template variable, the error can be reduced arbitrarily by using a data type with greater precision.

 
    #include <boost/math/differentiation/autodiff.hpp>
    #include <iostream>
    
    using namespace boost::math::differentiation;
    
    template<typename W,typename X,typename Y,typename Z>
    autodiff::promote<W,X,Y,Z> f(const W& w, const X& x, const Y& y, const Z& z)
    {
      using namespace std;
      return exp(w*sin(x*log(y)/z) + sqrt(w*z/(x*y))) + w*w/tan(z);
    }
    
    // Derivatives calculated from symbolic differentiation by Mathematica for comparison.
    const double answers[] = { 19878.406289804349223, 20731.748382749395173, 14667.607676239390148, 1840.5599364498131187,
      -9219.3180052370721296, -7272.3006340128117838, -2135.2963700622839242, 3095.0810272518467995, 4249.0267629086156274,
      2063.9890610627344166, -885.52841148764960841, -1962.1334204417431580, -1846.8998307870845186, -160.95901276032957552,
      1091.0394123416339941, 452.43955743452299467, 666.40139227277049900, -415.64641143336291078, -625.14641790399863613,
      369.94916697726171101, -24330.896138493893431, -18810.416051756267521, -4890.4061227023590999, 8833.0050547689764171,
      8484.3507396816137478, 3097.2041512403988935, -3255.0451367834406121, -4342.7785533321930979, -2407.9872379065234860,
      861.11739164703000843, 2436.7437257633086191, -19.246496107338277838, 187.78551488705117144, -1259.4660633352121952,
      -709.68605239721582613, 1423.0005586086045369, 484.92081333892339591, 763.97468850744531805, -327.41629182280555682,
      -1122.3377072484945211, 23973.060071923469893, 8840.5431517787968699, -9082.5710332215493783, -12270.273782892587177,
      -4320.4340714205998547, 3281.3519677072808985, 5880.3362630834187672, -1288.4827852197065498, -803.97135376265805266,
      -2986.3872453316983903, -586.73168598226583063, 3929.0731892807393562, 1453.7282809838266301, 1037.8780716859538297,
      -1482.7458052774013366, -1877.1347929338288106, -931.71387103692982071, 254.65655904203226329, 1391.2480647456116638,
      -431.48205631541379551, 16975.340053651795550, 19662.603563033417098, 15765.851307040200043, 3972.1550361959370138,
      -8681.7485397897205125, -7703.1830424603876567, -3049.7086965695187740, 2971.4696859922708762, 4370.1964998575500257,
      2524.6324733574356708, -656.60800002366790717, -2423.4529173252581326, -2074.9876642042632042, -381.22537949881329845,
      1219.5072457919973510, 805.38022398408368773, 838.40041900589123805, -390.61251971089838316, -828.20854892982357583,
      293.89998544549947901, -22965.859858439519778, -20026.691015299296217, -7316.0927450633559965, 8632.4661339726146593,
      8987.0468828704522662, 4199.9253995361375411, -2958.4298508960628932, -5665.5638912186240622, -2945.4045522503416159,
      555.65662724782625247, 2936.7964035500791392, 651.51916507471100081, 444.76294274861551486, -1390.9896717990958013,
      -1142.8614689467638609, 1541.9787231173408435, 455.71460632938144702, 998.79435039403570373, -204.84855819811212954,
      -1560.3541154604787861, 25278.294506052472235, 11873.223371790464699, -8242.1873033688781033, -15939.980564174657519,
      -5648.8335396980314868, 2751.5139261227171185, 7349.4320024790771292, 194.99725459803711274, -402.81568576826882656,
      -3518.8719086830633712, -1494.3047934746826191, 4640.9275094260800875, 1585.7577052032271420, 1565.1699924044071379,
      -1513.2598097335400189, -2974.4378726746800928, -1203.2362926538234416, 72.524259498791533840, 1871.6252742534199495,
      -2.4899843373796816664, 14462.744235186331026, 18367.747409164327117, 16565.763244996739614, 6054.3152526511029520,
      -8084.9812719820301461, -7988.3143591282012972, -3989.3193469414926985, 2616.7211865346490167, 4420.8592709704865621,
      2973.0335197645479091, -324.14530169827137080, -2843.2420399589692219, -2281.4618061432895177, -642.93532295820559249,
      1299.2872741769553585, 1238.5970833720697622, 1021.3340427708481651, -329.05293450692710796, -1046.2543015440520751,
      134.73430395544806552, -21431.416435076611924, -20856.882814790157847, -9829.2619705919309076, 7806.8586470778118280,
      9319.7000856495681801, 5319.8987680257582564, -2387.9548264668417364, -6958.2985251653597607, -3468.5391063919725607,
      130.41672533427094017, 3371.1399302351759874, 1569.2326780049081053, 750.09121011790652458, -1462.2572096265974522,
      -1661.5778096302406157, 1509.6285286038691333, 383.89509025808162595, 1248.0510963436380133, 17.185695642652602749,
      -2038.0245980026048531, 26118.981320178235148, 14943.619434822279033, -6650.6862622761310724, -19519.815295474040679,
      -6983.1902365008486475, 1899.2975028736889830, 8715.0036526429634882, 2368.1506906818643019, 136.89207930934828319,
      -3954.7327061634171420, -2673.5564402311867864, 5078.4839352490435947, 1643.4591437212048172, 2182.2169795063802937,
      -1345.8388309636205015, -4309.2853506291084135, -1488.0508699224178177, -228.05849430703437209, 2373.3989404257091779,
      773.84813281039280582, 12294.403877378555486, 16977.349665718583019, 17057.174756225031750, 8121.1897585118309359,
      -7458.4435414062843899, -8134.1311608827380587, -4912.8811586137844196, 2030.6531360989337179, 4407.4905277094127309,
      3392.4345688258927524, 104.03723558415061987, -3180.8176204844632144, -2460.5239870750694373, -938.22093140691334328,
      1315.2469055718764567, 1735.8623924059921882, 1209.7596572231669549, -227.33200545666422971, -1266.1262099919292594,
      -123.07945723381491568, -19806.907943338346855, -21314.816354405752293, -12317.583844301308050, 6349.4186598882814744,
      9489.8196876965277351, 6409.5389484563099944, -1550.2817990131252676, -8109.7111997852175121, -3957.8403302968748777,
      -404.07965558366678588, 3693.6143513011819801, 2716.1466583227900648, 1094.5910866413989005, -1456.2696455499464209,
      -2244.3806087356369623, 1268.5938915562618711, 265.22067303277493466, 1496.0915787786394884, 354.61373510477227819,
      -2508.4771100486841292, 26517.861408751573247, 17922.983877419151441, -4328.2591421276680409, -22704.702459400809491,
      -8268.6137471737389714, 740.40560743926114647, 9848.9001828360350810, 5213.5983414762103377, 801.24629237235082333,
      -4241.8701339207678459, -4092.2413558685505706, 5074.4359092060839438, 1607.7653292548209160, 2861.1556511165675262,
      -918.93105463172960902, -5803.2113236460920193, -1767.5418979944773144, -663.06462075200757263, 2837.9031946139384145,
      1976.3196007477977178 };
    
    int main()
    {
      constexpr int Nw=3; // Max order of derivative to calculate for w
      constexpr int Nx=2; // Max order of derivative to calculate for x
      constexpr int Ny=4; // Max order of derivative to calculate for y
      constexpr int Nz=3; // Max order of derivative to calculate for z
      const autodiff::variable<double,Nw> w(11);
      const autodiff::variable<double,0,Nx> x(12);
      const autodiff::variable<double,0,0,Ny> y(13);
      const autodiff::variable<double,0,0,0,Nz> z(14);
      const auto v = f(w,x,y,z); // auto = autodiff::variable<double,Nw,Nx,Ny,Nz>
      int ia=0;
      double max_relative_error=0;
      for (int iw=0 ; iw<=Nw ; ++iw)
        for (int ix=0 ; ix<=Nx ; ++ix)
          for (int iy=0 ; iy<=Ny ; ++iy)
            for (int iz=0 ; iz<=Nz ; ++iz)
            {
              const double value = v.derivative(iw,ix,iy,iz);
              const double error = std::fabs(value/answers[ia++] - 1);
              max_relative_error = std::max(error, max_relative_error);
            }
      std::cout << "max_relative_error = " << std::setprecision(3) << max_relative_error
        << " out of " << ia << " calculated values." << std::endl;
      return 0;
    }
    /*
    Output:
    max_relative_error = 6.82e-13 out of 240 calculated values.
    **/



[h1:mathematics 
Mathematics]

In order for the usage of the autodiff library to make sense, a basic understanding of the mathematics will help.

[h2:taylor-series 
Truncated Taylor Series]

Basic calculus courses teach that a real [@https://en.wikipedia.org/wiki/Analytic_function analytic function] [autodiff_equation form_22.png] is one which can be expressed as a Taylor series at a point [autodiff_equation form_23.png]:


[:[:[autodiff_equation form_24.png]]]


One way of thinking about this form is that given the value of an analytic function [autodiff_equation form_25.png] and its derivatives [autodiff_equation form_26.png] evaluated at a point [autodiff_equation form_1.png], then the value of the function [autodiff_equation form_27.png] can be obtained at any other point [autodiff_equation form_28.png] using the above formula.

Let us make the substitution [autodiff_equation form_29.png] and rewrite the above equation to get:


[:[:[autodiff_equation form_30.png]]]


Now consider [autodiff_equation form_6.png] as [*an abstract algebraic entity that never acquires a numeric value], much like one does in basic algebra with variables like [autodiff_equation form_31.png] or [autodiff_equation form_32.png]. For example, we can still manipulate entities like [autodiff_equation form_33.png] and [autodiff_equation form_34.png] without having to assign specific numbers to them.

Using this formula, autodiff goes in the other direction. Given a general formula/algorithm for calculating [autodiff_equation form_35.png], the derivatives are obtained from the coefficients of the powers of [autodiff_equation form_6.png] in the resulting computation. The general coefficient for [autodiff_equation form_36.png] is


[:[:[autodiff_equation form_37.png]]]


Thus to obtain [autodiff_equation form_38.png], the coefficient of [autodiff_equation form_36.png] is multiplied by [autodiff_equation form_39.png].

[h3:taylor-series-example 
Example]

Apply the above technique to calculate the derivatives of ['f(x)=x[super 4]] at [autodiff_equation form_40.png].

The first step is to evaluate [autodiff_equation form_35.png] and simply go through the calculation/algorithm, treating [autodiff_equation form_6.png] as an abstract algebraic entity:


[:[:[autodiff_equation form_41.png]]]


Equating the powers of [autodiff_equation form_6.png] from this result with the above [autodiff_equation form_6.png]-taylor expansion yields the following equalities: 

[:[:[autodiff_equation form_42.png]]]


Multiplying both sides by the respective factorials gives 

[:[:[autodiff_equation form_43.png]]]


These values can be directly confirmed by the [@https://en.wikipedia.org/wiki/Power_rule power rule] applied to ['f(x)=x[super 4]].



[h2:arithmetic 
Arithmetic]

What was essentially done above was to take a formula/algorithm for calculating [autodiff_equation form_25.png] from a number [autodiff_equation form_1.png], and instead apply the same formula/algorithm to a polynomial [autodiff_equation form_3.png]. Intermediate steps operate on values of the form


[:[:[autodiff_equation form_44.png]]]


and the final return value is of this polynomial form as well. In other words, the normal arithmetic operators [autodiff_equation form_45.png] applied to numbers [autodiff_equation form_31.png] are instead applied to polynomials [autodiff_equation form_46.png]. Through the overloading of C++ operators and functions, floating point data types are replaced with data types that represent these polynomials. More specifically, C++ types such as `double` are replaced with `std::array<double,N+1>`, which hold the above [autodiff_equation form_47.png] coefficients [autodiff_equation form_48.png], and are wrapped in a `class` that overloads all of the arithmetic operators.

The logic of these arithmetic operators simply mirror that which is applied to polynomials. We'll look at each of the 4 arithmetic operators in detail.

[h3:arithmetic-addition 
Addition]

Given polynomials [autodiff_equation form_46.png] and [autodiff_equation form_49.png], how is [autodiff_equation form_50.png] calculated?

To answer this, one simply expands [autodiff_equation form_46.png] and [autodiff_equation form_49.png] into their polynomial forms and add them together:


[:[:[autodiff_equation form_51.png]]]


[h3:arithmetic-subtraction 
Subtraction]

Subtraction follows the same form as addition:


[:[:[autodiff_equation form_52.png]]]


[h3:arithmetic-multiplication 
Multiplication]

Multiplication is a bit more interesting:


[:[:[autodiff_equation form_53.png]]]


In the case of multiplication, terms involving powers of [autodiff_equation form_6.png] greater than /N/, collectively denoted by [autodiff_equation form_5.png], are simply discarded. Fortunately, the values of [autodiff_equation form_54.png] for [autodiff_equation form_55.png] do not depend on any of these discarded terms, so there is no loss of precision in the final answer. The only information that is lost are the values of higher order derivatives, which we are not interested in anyway. If we were, then we would have simply chosen a larger value of /N/ to begin with.

[h3:arithmetic-division 
Division]

Division is not directly calculated as are the others. Instead, to find the components of [autodiff_equation form_56.png] we require that [autodiff_equation form_57.png]. This yields a recursive formula for the components [autodiff_equation form_54.png]:


[:[:[autodiff_equation form_58.png]]]


In the case of division, the values for [autodiff_equation form_54.png] must be calculated sequentially, since [autodiff_equation form_54.png] depends on the previously calculated values [autodiff_equation form_59.png].



[h2:general-functions 
General Functions]

When calling standard mathematical functions such as `log()`, `cos()`, etc. how should these be written in order to support autodiff variable types? That is, how should they be written to provide accurate derivatives?

To simplify notation, for a given polynomial [autodiff_equation form_60.png] define


[:[:[autodiff_equation form_61.png]]]


This allows for a concise expression of a general function /f/ of [autodiff_equation form_46.png]:


[:[:[autodiff_equation form_62.png]]]


where [autodiff_equation form_6.png] has been substituted with [autodiff_equation form_63.png] in the [autodiff_equation form_6.png]-taylor series for [autodiff_equation form_27.png]. This form gives a recipe for calculating [autodiff_equation form_64.png] in general from regular numeric calculations [autodiff_equation form_25.png], [autodiff_equation form_65.png], [autodiff_equation form_66.png], ... and successive powers of the epsilon terms [autodiff_equation form_63.png].

For an application in which we are interested in up to /N/ derivatives in [autodiff_equation form_31.png] the data structure to hold this information is an [autodiff_equation form_67.png]-element array `v` whose general element is


[:[:[autodiff_equation form_68.png]]]




[h2:multiple-variables 
Multiple Variables]

In C++, the generalization to mixed partial derivatives with multiple independent variables is conveniently achieved with recursion. To begin to see the recursive pattern, consider a two-variable function [autodiff_equation form_69.png]. Since [autodiff_equation form_31.png] and [autodiff_equation form_32.png] are independent, they require their own independent epsilons [autodiff_equation form_70.png] and [autodiff_equation form_71.png], respectively.

Expand [autodiff_equation form_69.png] for [autodiff_equation form_72.png]: 

[:[:[autodiff_equation form_73.png]]]


Next, expand [autodiff_equation form_74.png] for [autodiff_equation form_75.png]: 

[:[:[autodiff_equation form_76.png]]]


Similarly to the single-variable case, for an application in which we are interested in up to [autodiff_equation form_77.png] derivatives in [autodiff_equation form_31.png] and /N/ derivatives in [autodiff_equation form_32.png], the data structure to hold this information is an [autodiff_equation form_78.png] array `v` whose element at [autodiff_equation form_79.png] is


[:[:[autodiff_equation form_80.png]]]


The generalization to additional independent variables follows the same pattern. This is made more concrete with C++ code in the next section.



[h1:Usage 
Usage]

[h2:usage-single-variable 
Single Variable]

To calculate derivatives of a single variable [autodiff_equation form_31.png], at a particular value [autodiff_equation form_1.png], the following must be specified at compile-time:


# The numeric data type `T` of [autodiff_equation form_1.png]. Examples: `double`, `boost::multiprecision::cpp_dec_float_100`, etc.
# The [*maximum] derivative order [autodiff_equation form_77.png] that is to be calculated with respect to [autodiff_equation form_31.png].

Note that both of these requirements are entirely analogous to declaring and using a `std::array<T,N>`. `T` and `N` must be set as compile-time, but which elements in the array are accessed can be determined at run-time, just as the choice of what derivatives to query in autodiff can be made during run-time.

To declare and initialize [autodiff_equation form_31.png]:


    boost::math::differentiation::autodiff::variable<T,M> x(x0);
where `x0` is a run-time value of type `T`. Assuming `0 < M`, this represents the polynomial [autodiff_equation form_81.png]. Internally, the member variable of type `std::array<T,M>` is `v = { x0, 1, 0, 0, ... }`, consistent with the above mathematical treatise.

To find the derivatives [autodiff_equation form_38.png] for [autodiff_equation form_82.png] of a function [autodiff_equation form_83.png], the function can be represented as a template


    template<typename T>
    T f(T x);
Using a generic type `T` allows for `x` to be of a regular type such as `double`, but also allows for `boost::math::differentiation::autodiff::variable<>` types.

Internal calls to mathematical functions must allow for [@https://en.cppreference.com/w/cpp/language/adl argument-dependent lookup] (ADL). Many standard library functions are overloaded in the `boost::math::differentiation::autodiff` namespace. For example, instead of calling `std::cos(x)` from within `f`, include the line `using std::cos;` and call `cos(x)` without a namespace prefix.

Calling /f/ and retrieving the calculated value and derivatives:


    boost::math::differentiation::autodiff::variable<T,M> x(x0);
    boost::math::differentiation::autodiff::variable<T,M> y = f(x);
    for (int n=0 ; n<=M ; ++n)
        std::cout << "y.derivative("<<n<<") == " << y.derivative(n) << std::endl;
`y.derivative(0)` returns the undifferentiated value [autodiff_equation form_25.png], and `y.derivative(n)` returns [autodiff_equation form_38.png]. Casting `y` to type `T` also gives the undifferentiated value. In other words, the following 3 values are equal:

# `f(x0)`
# `y.derivative(0)`
# `static_cast<T>(y)`

[h2:usage-multiple-variables 
Multiple Variables]

Independent variables are represented in autodiff as independent dimensions within a multi-dimensional array. This is perhaps best illustrated with examples.

The following instantiates a variable of [autodiff_equation form_84.png] with up to 3 orders of derivatives: 

    boost::math::differentiation::autodiff::variable<double,3> x(13);
This instantiates ['an independent] value of [autodiff_equation form_85.png] with up to 4 orders of derivatives: 

    boost::math::differentiation::autodiff::variable<double,0,4> y(14);
Combining them together ['promotes] their data type automatically to the smallest multidimensional array that accommodates both. 

    auto z = 10*x*x + 50*x*y + 100*y*y; // z is promoted to boost::math::differentiation::autodiff::variable<double,3,4>
The object `z` holds a 2-dimensional array, thus `derivative(...)` is a 2-parameter method:


[:[:[autodiff_equation form_86.png]]]


A few values of the result can be confirmed through inspection: 

    z.derivative(2,0) == 20
    z.derivative(1,1) == 50
    z.derivative(0,2) == 200
Note how the position of the parameters in `derivative(..)` match how `x` and `y` were declared. This will be clarified next.

[h3:two-rules 
Two Rules of Variable Initialization]

In general, there are two rules to keep in mind when dealing with multiple variables:


# Independent variables correspond to parameter position, in both the declaration `boost::math::differentiation::autodiff::variable<T,...>` and calls to `derivative(...)`.
# The last template position in a value-initialized instance determines which variable a derivative will be taken with respect to.

Both rules are illustrated with an example in which there are 3 independent variables [autodiff_equation form_87.png] and 1 dependent variable [autodiff_equation form_88.png], though the following code readily generalizes to any number of independent variables, limited only by the C++ compiler/memory/platform. The maximum derivative order of each variable is `Nx`, `Ny`, and `Nz`, respectively. Then the type for `w` is `boost::math::differentiation::autodiff::variable<T,Nx,Ny,Nz>` and all possible mixed partial derivatives are available via 

[:[:[autodiff_equation form_89.png]]]


where [autodiff_equation form_90.png] are the numerical values at which the function /f/ and its derivatives are evaluated.

In code: 

    using namespace boost::math::differentiation;
    
    using var = autodiff::variable<double,Nx,Ny,Nz>; // Nx, Ny, Nz are constexpr size_t.
    
    var x = autodiff::variable<double,Nx>(x0);       // x0 is of type double
    var y = autodiff::variable<double,Nx,Ny>(y0);    // y0 is of type double
    var z = autodiff::variable<double,Nx,Ny,Nz>(z0); // z0 is of type double
    
    var w = f(x,y,z);
    
    for (size_t nx=0 ; nx<=Nx ; ++nx)
        for (size_t ny=0 ; ny<=Ny ; ++ny)
            for (size_t nz=0 ; nz<=Nz ; ++nz)
                std::cout << "w.derivative("<<nx<<','<<ny<<','<<nz<<") == " << w.derivative(nx,ny,nz) << std::endl;
Note how `x`, `y`, and `z` are initialized: the last template parameter determines which variable [autodiff_equation form_91.png] or [autodiff_equation form_92.png] a derivative is taken with respect to. In terms of the [autodiff_equation form_6.png]-polynomials above, this determines whether to add [autodiff_equation form_93.png] or [autodiff_equation form_15.png] to [autodiff_equation form_94.png] or [autodiff_equation form_95.png], respectively.

In contrast, the following initialization of `x` would be INCORRECT: 

    var x = autodiff::variable<T,Nx,0>(x0); // WRONG
Mathematically, this represents [autodiff_equation form_96.png], since the last template parameter corresponds to the [autodiff_equation form_32.png] variable, and thus the resulting value will be invalid.

[h3:type-promotion 
Type Promotion]

The previous example can be optimized to save some unnecessary computation, by declaring smaller arrays, and relying on autodiff's automatic type-promotion: 

    using namespace boost::math::differentiation;
    
    autodiff::variable<double,Nx> x(x0);
    autodiff::variable<double,0,Ny> y(y0);
    autodiff::variable<double,0,0,Nz> z(z0);
    
    autodiff::variable<double,Nx,Ny,Nz> w = f(x,y,z);
    
    for (size_t nx=0 ; nx<=Nx ; ++nx)
        for (size_t ny=0 ; ny<=Ny ; ++ny)
            for (size_t nz=0 ; nz<=Nz ; ++nz)
                std::cout << "w.derivative("<<nx<<','<<ny<<','<<nz<<") == " << w.derivative(nx,ny,nz) << std::endl;
For example, if one of the first steps in the computation of /f/ was `z*z`, then a significantly less number of multiplications and additions may occur if `z` is declared as `variable<double,0,0,Nz>` as opposed to `variable<double,Nx,Ny,Nz>`. There is no loss of precision with the former, since the extra dimensions represent 0 values. Once `z` is combined with `x` and `y` during the computation, the types will be promoted as necessary. This is the recommended way to initialize variables in autodiff.

[h2:requirements Requirements]

# C++11 compiler, but optimized for C++17. Visual Studio 2015 is not supported.
# Maximum derivative orders are set at compile-time. This allows for compile-time calculation of memory requirements for use with `std::array<>`, so that use of dynamic memory allocation is avoided.
# Mathematical functions, whose derivatives are desired, should accept generic types (template variables) for the parameters that derivatives are calculated with respect to, and internal function calls should allow for [@https://en.cppreference.com/w/cpp/language/adl argument-dependent lookup] (ADL) on these parameters.

[h2:quick-install 
Quick Install]

Since this is a header-only library, there is an easy way to use/test this library without having to install it system-wide or compile libraries ahead of time:


# Download the latest version of boost from [@https://www.boost.org/ https://www.boost.org/] (minimum 1.70.0) and uncompress it.
# A single directory is created, for example, `./boost_1_70_0`.
# Add the new directory to your include path when compiling. Example: `g++ -I./boost_1_70_0 ./boost_1_70_0/libs/math/example/autodiff_fourth_power.cpp`

Long term it is recommended to install boost via a package manager specific to your operating system, or with the `INSTALL` directions provided in the download.

[endsect]
